{
  "language": "Solidity",
  "sources": {
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.6.0 <0.8.0;\n\ncontract ERC20 {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n\n    uint256 public totalSupply;\n    string public name;\n    string public symbol;\n\n    constructor(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) public {\n        balances[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n        name = _name;\n        symbol = _symbol;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) external returns (bool) {\n        require(balances[msg.sender] >= _amount, \"You don't have enough balance to make this transfer!\");\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool) {\n        require(\n            balances[_from] >= _amount,\n            \"Can't transfer from the desired account because it doesn't have enough balance.\"\n        );\n\n        require(\n            allowances[_from][msg.sender] >= _amount,\n            \"Can't transfer from the desired account because you don't have enough of an allowance.\"\n        );\n\n        balances[_to] += _amount;\n        balances[_from] -= _amount;\n\n        emit Transfer(_from, _to, _amount);\n\n        return true;\n    }\n\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        allowances[msg.sender][_spender] = _amount;\n\n        emit Approval(msg.sender, _spender, _amount);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n}\n"
    },
    "contracts/L1ERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {OVM_L1ERC20Gateway} from \"@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol\";\nimport {iOVM_ERC20} from \"@eth-optimism/contracts/build/contracts/iOVM/precompiles/iOVM_ERC20.sol\";\n\ncontract L1ERC20Gateway is OVM_L1ERC20Gateway {\n    constructor(\n        iOVM_ERC20 _l1ERC20,\n        address _l2DepositedERC20,\n        address _l1messenger\n    ) OVM_L1ERC20Gateway(_l1ERC20, _l2DepositedERC20, _l1messenger) {}\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/OVM_L1ERC20Gateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm \npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\nimport { Abs_L1TokenGateway } from \"./Abs_L1TokenGateway.sol\";\nimport { iOVM_ERC20 } from \"../../../iOVM/precompiles/iOVM_ERC20.sol\";\n\n/**\n * @title OVM_L1ERC20Gateway\n * @dev The L1 ERC20 Gateway is a contract which stores deposited L1 funds that are in use on L2.\n * It synchronizes a corresponding L2 ERC20 Gateway, informing it of deposits, and listening to it\n * for newly finalized withdrawals.\n *\n * NOTE: This contract extends Abs_L1TokenGateway, which is where we\n * takes care of most of the initialization and the cross-chain logic.\n * If you are looking to implement your own deposit/withdrawal contracts, you\n * may also want to extend the abstract contract in a similar manner.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\ncontract OVM_L1ERC20Gateway is Abs_L1TokenGateway {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n    \n    iOVM_ERC20 public l1ERC20;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l1ERC20 L1 ERC20 address this contract stores deposits for\n     * @param _l2DepositedERC20 L2 Gateway address on the chain being deposited into\n     */\n    constructor(\n        iOVM_ERC20 _l1ERC20,\n        address _l2DepositedERC20,\n        address _l1messenger \n    )\n        Abs_L1TokenGateway(\n            _l2DepositedERC20,\n            _l1messenger\n        )\n    {\n        l1ERC20 = _l1ERC20;\n    }\n\n\n    /**************\n     * Accounting *\n     **************/\n\n    /**\n     * @dev When a deposit is initiated on L1, the L1 Gateway\n     * transfers the funds to itself for future withdrawals\n     *\n     * @param _from L1 address ETH is being deposited from\n     * @param _to L2 address that the ETH is being deposited to\n     * @param _amount Amount of ERC20 to send\n     */\n    function _handleInitiateDeposit(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        override\n    {\n         // Hold on to the newly deposited funds\n        l1ERC20.transferFrom(\n            _from,\n            address(this),\n            _amount\n        );\n    }\n\n    /**\n     * @dev When a withdrawal is finalized on L1, the L1 Gateway\n     * transfers the funds to the withdrawer\n     *\n     * @param _to L1 address that the ERC20 is being withdrawn to\n     * @param _amount Amount of ERC20 to send\n     */\n    function _handleFinalizeWithdrawal(\n        address _to,\n        uint _amount\n    )\n        internal\n        override\n    {\n        // Transfer withdrawn funds out to withdrawer\n        l1ERC20.transfer(_to, _amount);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/iOVM/precompiles/iOVM_ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title iOVM_ERC20\n */\ninterface iOVM_ERC20 {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    /// total amount of tokens\n    function totalSupply() external view returns (uint256);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/iOVM/bridge/tokens/iOVM_L1TokenGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title iOVM_L1TokenGateway\n */\ninterface iOVM_L1TokenGateway {\n\n    /**********\n     * Events *\n     **********/\n\n    event DepositInitiated(\n        address indexed _from,\n        address _to,\n        uint256 _amount\n    );\n  \n    event WithdrawalFinalized(\n        address indexed _to,\n        uint256 _amount\n    );\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function deposit(\n        uint _amount\n    )\n        external;\n\n    function depositTo(\n        address _to,\n        uint _amount\n    )\n        external;\n\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    function finalizeWithdrawal(\n        address _to,\n        uint _amount\n    )\n        external;\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/Abs_L1TokenGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// @unsupported: ovm \npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\nimport { iOVM_L2DepositedToken } from \"../../../iOVM/bridge/tokens/iOVM_L2DepositedToken.sol\";\n\n/* Library Imports */\nimport { OVM_CrossDomainEnabled } from \"../../../libraries/bridge/OVM_CrossDomainEnabled.sol\";\n\n/**\n * @title Abs_L1TokenGateway\n * @dev An L1 Token Gateway is a contract which stores deposited L1 funds that are in use on L2.\n * It synchronizes a corresponding L2 representation of the \"deposited token\", informing it\n * of new deposits and releasing L1 funds when there are newly finalized withdrawals.\n *\n * NOTE: This abstract contract gives all the core functionality of an L1 token gateway, \n * but provides easy hooks in case developers need extensions in child contracts.\n * In many cases, the default OVM_L1ERC20Gateway will suffice.\n *\n * Compiler used: solc\n * Runtime target: EVM\n */\nabstract contract Abs_L1TokenGateway is iOVM_L1TokenGateway, OVM_CrossDomainEnabled {\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    address public l2DepositedToken;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l2DepositedToken iOVM_L2DepositedToken-compatible address on the chain being deposited into.\n     * @param _l1messenger L1 Messenger address being used for cross-chain communications.\n     */\n    constructor(\n        address _l2DepositedToken,\n        address _l1messenger \n    )\n        OVM_CrossDomainEnabled(_l1messenger)\n    {\n        l2DepositedToken = _l2DepositedToken;\n    }\n\n    /********************************\n     * Overridable Accounting logic *\n     ********************************/\n\n    // Default gas value which can be overridden if more complex logic runs on L2.\n    uint32 public DEFAULT_FINALIZE_DEPOSIT_L2_GAS = 1200000;\n\n    /**\n     * @dev Core logic to be performed when a withdrawal is finalized on L1.\n     * In most cases, this will simply send locked funds to the withdrawer.\n     *\n     * @param _to Address being withdrawn to.\n     * @param _amount Amount being withdrawn.\n     */\n    function _handleFinalizeWithdrawal(\n        address _to,\n        uint256 _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Implement me in child contracts\");\n    }\n\n    /**\n     * @dev Core logic to be performed when a deposit is initiated on L1.\n     * In most cases, this will simply send locked funds to the withdrawer.\n     *\n     * @param _from Address being deposited from on L1.\n     * @param _to Address being deposited into on L2.\n     * @param _amount Amount being deposited.\n     */\n    function _handleInitiateDeposit(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Implement me in child contracts\");\n    }\n\n    /**\n     * @dev Overridable getter for the L2 gas limit, in the case it may be\n     * dynamic, and the above public constant does not suffice.\n     *\n     */\n\n    function getFinalizeDepositL2Gas()\n        public\n        view\n        returns(\n            uint32\n        )\n    {\n        return DEFAULT_FINALIZE_DEPOSIT_L2_GAS;\n    }\n\n    /**************\n     * Depositing *\n     **************/\n\n    /**\n     * @dev deposit an amount of the ERC20 to the caller's balance on L2\n     * @param _amount Amount of the ERC20 to deposit\n     */\n    function deposit(\n        uint _amount\n    )\n        public\n        override\n    {\n        _initiateDeposit(msg.sender, msg.sender, _amount);\n    }\n\n    /**\n     * @dev deposit an amount of ERC20 to a recipients's balance on L2\n     * @param _to L2 address to credit the withdrawal to\n     * @param _amount Amount of the ERC20 to deposit\n     */\n    function depositTo(\n        address _to,\n        uint _amount\n    )\n        public\n        override\n    {\n        _initiateDeposit(msg.sender, _to, _amount);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by informing the L2 Deposited Token\n     * contract of the deposit and calling a handler to lock the L1 funds. (e.g. transferFrom)\n     *\n     * @param _from Account to pull the deposit from on L1\n     * @param _to Account to give the deposit to on L2\n     * @param _amount Amount of the ERC20 to deposit.\n     */\n    function _initiateDeposit(\n        address _from,\n        address _to,\n        uint _amount\n    )\n        internal\n    {\n        // Call our deposit accounting handler implemented by child contracts.\n        _handleInitiateDeposit(\n            _from,\n            _to,\n            _amount\n        );\n\n        // Construct calldata for l2DepositedToken.finalizeDeposit(_to, _amount)\n        bytes memory data = abi.encodeWithSelector(\n            iOVM_L2DepositedToken.finalizeDeposit.selector,\n            _to,\n            _amount\n        );\n\n        // Send calldata into L2\n        sendCrossDomainMessage(\n            l2DepositedToken,\n            data,\n            getFinalizeDepositL2Gas()\n        );\n\n        emit DepositInitiated(_from, _to, _amount);\n    }\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a withdrawal from L2 to L1, and credit funds to the recipient's balance of the \n     * L1 ERC20 token. \n     * This call will fail if the initialized withdrawal from L2 has not been finalized. \n     *\n     * @param _to L1 address to credit the withdrawal to\n     * @param _amount Amount of the ERC20 to withdraw\n     */\n    function finalizeWithdrawal(\n        address _to,\n        uint _amount\n    )\n        external\n        override \n        onlyFromCrossDomainAccount(l2DepositedToken)\n    {\n        // Call our withdrawal accounting handler implemented by child contracts.\n        _handleFinalizeWithdrawal(\n            _to,\n            _amount\n        );\n\n        emit WithdrawalFinalized(_to, _amount);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/iOVM/bridge/tokens/iOVM_L2DepositedToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title iOVM_L2DepositedToken\n */\ninterface iOVM_L2DepositedToken {\n\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _from,\n        address _to,\n        uint256 _amount\n    );\n\n    event DepositFinalized(\n        address indexed _to,\n        uint256 _amount\n    );    \n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    function withdraw(\n        uint _amount\n    )\n        external;\n\n    function withdrawTo(\n        address _to,\n        uint _amount\n    )\n        external;\n\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    function finalizeDeposit(\n        address _to,\n        uint _amount\n    )\n        external;\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/libraries/bridge/OVM_CrossDomainEnabled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n/* Interface Imports */\nimport { iAbs_BaseCrossDomainMessenger } from \"../../iOVM/bridge/messaging/iAbs_BaseCrossDomainMessenger.sol\";\n\n/**\n * @title OVM_CrossDomainEnabled\n * @dev Helper contract for contracts performing cross-domain communications\n *\n * Compiler used: defined by inheriting contract\n * Runtime target: defined by inheriting contract\n */\ncontract OVM_CrossDomainEnabled {\n    // Messenger contract used to send and recieve messages from the other domain.\n    address public messenger;\n\n    /***************\n     * Constructor *\n     ***************/    \n    constructor(\n        address _messenger\n    ) {\n        messenger = _messenger;\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * @notice Enforces that the modified function is only callable by a specific cross-domain account.\n     * @param _sourceDomainAccount The only account on the originating domain which is authenticated to call this function.\n     */\n    modifier onlyFromCrossDomainAccount(\n        address _sourceDomainAccount\n    ) {\n        require(\n            msg.sender == address(getCrossDomainMessenger()),\n            \"OVM_XCHAIN: messenger contract unauthenticated\"\n        );\n\n        require(\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\n            \"OVM_XCHAIN: wrong sender of cross-domain message\"\n        );\n\n        _;\n    }\n    \n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Gets the messenger, usually from storage.  This function is exposed in case a child contract needs to override.\n     * @return The address of the cross-domain messenger contract which should be used. \n     */\n    function getCrossDomainMessenger()\n        internal\n        virtual\n        returns(\n            iAbs_BaseCrossDomainMessenger\n        )\n    {\n        return iAbs_BaseCrossDomainMessenger(messenger);\n    }\n\n    /**\n     * @notice Sends a message to an account on another domain\n     * @param _crossDomainTarget The intended recipient on the destination domain\n     * @param _data The data to send to the target (usually calldata to a function with `onlyFromCrossDomainAccount()`)\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\n     */\n    function sendCrossDomainMessage(\n        address _crossDomainTarget,\n        bytes memory _data,\n        uint32 _gasLimit\n    ) internal {\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _data, _gasLimit);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/iOVM/bridge/messaging/iAbs_BaseCrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title iAbs_BaseCrossDomainMessenger\n */\ninterface iAbs_BaseCrossDomainMessenger {\n\n    /**********\n     * Events *\n     **********/\n    event SentMessage(bytes message);\n    event RelayedMessage(bytes32 msgHash);\n\n    /**********************\n     * Contract Variables *\n     **********************/\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/Abs_L2DepositedToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L2DepositedToken } from \"../../../iOVM/bridge/tokens/iOVM_L2DepositedToken.sol\";\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\n\n/* Library Imports */\nimport { OVM_CrossDomainEnabled } from \"../../../libraries/bridge/OVM_CrossDomainEnabled.sol\";\n\n/**\n * @title Abs_L2DepositedToken\n * @dev An L2 Deposited Token is an L2 representation of funds which were deposited from L1.\n * Usually contract mints new tokens when it hears about deposits into the L1 ERC20 gateway.\n * This contract also burns the tokens intended for withdrawal, informing the L1 gateway to release L1 funds.\n *\n * NOTE: This abstract contract gives all the core functionality of a deposited token implementation except for the\n * token's internal accounting itself.  This gives developers an easy way to implement children with their own token code.\n *\n * Compiler used: optimistic-solc\n * Runtime target: OVM\n */\nabstract contract Abs_L2DepositedToken is iOVM_L2DepositedToken, OVM_CrossDomainEnabled {\n\n    /*******************\n     * Contract Events *\n     *******************/\n\n    event Initialized(iOVM_L1TokenGateway _l1TokenGateway);\n\n    /********************************\n     * External Contract References *\n     ********************************/\n\n    iOVM_L1TokenGateway public l1TokenGateway;\n\n    /********************************\n     * Constructor & Initialization *\n     ********************************/\n\n    /**\n     * @param _l2CrossDomainMessenger L1 Messenger address being used for cross-chain communications.\n     */\n    constructor(\n        address _l2CrossDomainMessenger\n    )\n        OVM_CrossDomainEnabled(_l2CrossDomainMessenger)\n    {}\n\n    /**\n     * @dev Initialize this contract with the L1 token gateway address.\n     * The flow: 1) this contract gets deployed on L2, 2) the L1\n     * gateway is deployed with addr from (1), 3) L1 gateway address passed here.\n     *\n     * @param _l1TokenGateway Address of the corresponding L1 gateway deployed to the main chain\n     */\n\n    function init(\n        iOVM_L1TokenGateway _l1TokenGateway\n    )\n        public\n    {\n        require(address(l1TokenGateway) == address(0), \"Contract has already been initialized\");\n\n        l1TokenGateway = _l1TokenGateway;\n        \n        emit Initialized(l1TokenGateway);\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    modifier onlyInitialized() {\n        require(address(l1TokenGateway) != address(0), \"Contract has not yet been initialized\");\n        _;\n    }\n\n    /********************************\n     * Overridable Accounting logic *\n     ********************************/\n\n    // Default gas value which can be overridden if more complex logic runs on L2.\n    uint32 constant DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS = 100000;\n\n    /**\n     * @dev Core logic to be performed when a withdrawal from L2 is initialized.\n     * In most cases, this will simply burn the withdrawn L2 funds.\n     *\n     * @param _to Address being withdrawn to\n     * @param _amount Amount being withdrawn\n     */\n\n    function _handleInitiateWithdrawal(\n        address _to,\n        uint _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Accounting must be implemented by child contract.\");\n    }\n\n    /**\n     * @dev Core logic to be performed when a deposit from L2 is finalized on L2.\n     * In most cases, this will simply _mint() to credit L2 funds to the recipient.\n     *\n     * @param _to Address being deposited to on L2\n     * @param _amount Amount which was deposited on L1\n     */\n    function _handleFinalizeDeposit(\n        address _to,\n        uint _amount\n    )\n        internal\n        virtual\n    {\n        revert(\"Accounting must be implemented by child contract.\");\n    }\n\n    /**\n     * @dev Overridable getter for the *L1* gas limit of settling the withdrawal, in the case it may be\n     * dynamic, and the above public constant does not suffice.\n     *\n     */\n\n    function getFinalizeWithdrawalL1Gas()\n        public\n        view\n        virtual\n        returns(\n            uint32\n        )\n    {\n        return DEFAULT_FINALIZE_WITHDRAWAL_L1_GAS;\n    }\n\n\n    /***************\n     * Withdrawing *\n     ***************/\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _amount Amount of the token to withdraw\n     */\n    function withdraw(\n        uint _amount\n    )\n        external\n        override\n        onlyInitialized()\n    {\n        _initiateWithdrawal(msg.sender, _amount);\n    }\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1\n     * @param _to L1 adress to credit the withdrawal to\n     * @param _amount Amount of the token to withdraw\n     */\n    function withdrawTo(\n        address _to,\n        uint _amount\n    )\n        external\n        override\n        onlyInitialized()\n    {\n        _initiateWithdrawal(_to, _amount);\n    }\n\n    /**\n     * @dev Performs the logic for deposits by storing the token and informing the L2 token Gateway of the deposit.\n     *\n     * @param _to Account to give the withdrawal to on L1\n     * @param _amount Amount of the token to withdraw\n     */\n    function _initiateWithdrawal(\n        address _to,\n        uint _amount\n    )\n        internal\n    {\n        // Call our withdrawal accounting handler implemented by child contracts (usually a _burn)\n        _handleInitiateWithdrawal(_to, _amount);\n\n        // Construct calldata for l1TokenGateway.finalizeWithdrawal(_to, _amount)\n        bytes memory data = abi.encodeWithSelector(\n            iOVM_L1TokenGateway.finalizeWithdrawal.selector,\n            _to,\n            _amount\n        );\n\n        // Send message up to L1 gateway\n        sendCrossDomainMessage(\n            address(l1TokenGateway),\n            data,\n            getFinalizeWithdrawalL1Gas()\n        );\n\n        emit WithdrawalInitiated(msg.sender, _to, _amount);\n    }\n\n    /************************************\n     * Cross-chain Function: Depositing *\n     ************************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this \n     * L2 token. \n     * This call will fail if it did not originate from a corresponding deposit in OVM_l1TokenGateway. \n     *\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     */\n    function finalizeDeposit(\n        address _to,\n        uint _amount\n    )\n        external\n        override \n        onlyInitialized()\n        onlyFromCrossDomainAccount(address(l1TokenGateway))\n    {\n        _handleFinalizeDeposit(_to, _amount);\n        emit DepositFinalized(_to, _amount);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/OVM_L2DepositedERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Interface Imports */\nimport { iOVM_L1TokenGateway } from \"../../../iOVM/bridge/tokens/iOVM_L1TokenGateway.sol\";\n\n/* Contract Imports */\nimport { UniswapV2ERC20 } from \"../../../libraries/standards/UniswapV2ERC20.sol\";\n\n/* Library Imports */\nimport { Abs_L2DepositedToken } from \"./Abs_L2DepositedToken.sol\";\n\n/**\n * @title OVM_L2DepositedERC20\n * @dev The L2 Deposited ERC20 is an ERC20 implementation which represents L1 assets deposited into L2.\n * This contract mints new tokens when it hears about deposits into the L1 ERC20 gateway.\n * This contract also burns the tokens intended for withdrawal, informing the L1 gateway to release L1 funds.\n *\n * NOTE: This contract implements the Abs_L2DepositedToken contract using Uniswap's ERC20 as the implementation.\n * Alternative implementations can be used in this similar manner.\n *\n * Compiler used: optimistic-solc\n * Runtime target: OVM\n */\ncontract OVM_L2DepositedERC20 is Abs_L2DepositedToken, UniswapV2ERC20 {\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _l2CrossDomainMessenger Cross-domain messenger used by this contract.\n     * @param _name ERC20 name\n     * @param _symbol ERC20 symbol\n     */\n    constructor(\n        address _l2CrossDomainMessenger,\n        string memory _name,\n        string memory _symbol\n    )\n        public\n        Abs_L2DepositedToken(_l2CrossDomainMessenger)\n        UniswapV2ERC20(_name, _symbol)\n    {}\n\n    // When a withdrawal is initiated, we burn the withdrawer's funds to prevent subsequent L2 usage.\n    function _handleInitiateWithdrawal(\n        address _to,\n        uint _amount\n    )\n        internal\n        override\n    {\n        _burn(msg.sender, _amount);\n    }\n\n    // When a deposit is finalized, we credit the account on L2 with the same amount of tokens.\n    function _handleFinalizeDeposit(\n        address _to,\n        uint _amount\n    )\n        internal\n        override\n    {\n        _mint(_to, _amount);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/libraries/standards/UniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.16 <0.8.0;\n\nimport './IUniswapV2ERC20.sol';\nimport './UniSafeMath.sol';\n\ncontract UniswapV2ERC20 is IUniswapV2ERC20 {\n    using UniSafeMath for uint;\n\n    string public override name;\n    string public override symbol;\n    uint8 public constant override decimals = 18;\n    uint public override totalSupply;\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public override nonces;\n\n    constructor(\n    string memory _name,\n        string memory _symbol\n    ) public {\n        name = _name;\n        symbol = _symbol;\n\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/libraries/standards/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.16 <0.8.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@eth-optimism/contracts/build/contracts/libraries/standards/UniSafeMath.sol": {
      "content": "pragma solidity >=0.5.16 <0.8.0;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary UniSafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/L2DepositedERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {OVM_L2DepositedERC20} from \"@eth-optimism/contracts/build/contracts/OVM/bridge/tokens/OVM_L2DepositedERC20.sol\";\n\ncontract L2DepositedERC20 is OVM_L2DepositedERC20 {\n    constructor(\n        address _l2CrossDomainMessenger,\n        string memory _name,\n        string memory _symbol\n    ) OVM_L2DepositedERC20(_l2CrossDomainMessenger, _name, _symbol) {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
